# core/dynamic_analyzer.py
import os
import psutil
import threading
from datetime import datetime
from typing import Dict, List
from utils.logging_utils import setup_logging
from utils.sandbox_utils import is_in_vm, isolate_network, restore_network
from utils.file_utils import create_safe_directory
from .base import AnalyzerBase

class DynamicAnalyzer(AnalyzerBase):

    def __init__(self, sample_path: str, timeout: int = 60):
        super().__init__()
        self.sample_path = sample_path
        self.timeout = timeout
        self.logger = setup_logging('data/logs')
        self.working_dir = 'data/workspace'
        self.process_list = []
        self.file_changes = []
        self.network_connections = []
        self.registry_changes = []
        self.monitoring = False

    def analyze(self) -> Dict:
        try:
            self._start_analysis()

            if not is_in_vm():
                self.logger.error("Analysis must be run in a VM")
                return {'error': 'Not running in VM'}

            if not create_safe_directory(self.working_dir):
                self.logger.error("Failed to create safe workspace")
                return {'error': 'Workspace creation failed'}

            if not isolate_network():
                self.logger.error("Failed to isolate network")
                return {'error': 'Network isolation failed'}

            self.logger.info("Starting dynamic analysis")
            results = self._run_analysis()
            
            self._end_analysis()  # From base class
            return results

        except Exception as e:
            self.logger.error(f"Dynamic analysis failed: {str(e)}")
            return {'error': str(e)}

    def _run_analysis(self) -> Dict:
        try:
            self.monitoring = True
            monitor_threads = [
                threading.Thread(target=self._monitor_processes),
                threading.Thread(target=self._monitor_files),
                threading.Thread(target=self._monitor_network),
                threading.Thread(target=self._monitor_registry)
            ]

            for thread in monitor_threads:
                thread.start()

            process = psutil.Popen([self.sample_path])
            self.process_list.append(process.pid)

            time.sleep(self.timeout)

            self.monitoring = False
            for thread in monitor_threads:
                thread.join()
            return self._collect_results()

        except Exception as e:
            self.logger.error(f"Analysis execution failed: {str(e)}")
            self.monitoring = False
            return {'error': str(e)}

    def _monitor_processes(self):
        initial_processes = set(psutil.process_iter())

        while self.monitoring:
            current_processes = set(psutil.process_iter())
            new_processes = current_processes - initial_processes
            
            for process in new_processes:
                try:
                    self.process_list.append({
                        'pid': process.pid,
                        'name': process.name(),
                        'cmdline': process.cmdline(),
                        'create_time': datetime.fromtimestamp(
                            process.create_time()
                        ).strftime('%Y-%m-%d %H:%M:%S')
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue            
            time.sleep(1)

    def _monitor_files(self):
        initial_files = set(os.listdir())
        
        while self.monitoring:
            current_files = set(os.listdir())
            new_files = current_files - initial_files
            deleted_files = initial_files - current_files
            
            for file in new_files:
                self.file_changes.append({
                    'action': 'created',
                    'file': file,
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                })
            
            for file in deleted_files:
                self.file_changes.append({
                    'action': 'deleted',
                    'file': file,
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                })
            
            initial_files = current_files
            time.sleep(1)

    def _monitor_network(self):

        while self.monitoring:
            for pid in self.process_list:
                try:
                    process = psutil.Process(pid)
                    connections = process.connections()
                    for conn in connections:
                        self.network_connections.append({
                            'pid': pid,
                            'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}",
                            'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                            'status': conn.status,
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            time.sleep(1)

    def _monitor_registry(self):

        if os.name == 'nt':  # windows
            import winreg
            pass

    def _collect_results(self) -> Dict:
        return {
            'processes': self.process_list,
            'file_changes': self.file_changes,
            'network_connections': self.network_connections,
            'registry_changes': self.registry_changes,
            'analysis_metadata': self._add_metadata(),
            'timestamp': datetime.now().isoformat()
        }