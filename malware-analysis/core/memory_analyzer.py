# core/memory_analyzer.py

import volatility3
from volatility3.framework import contexts, automagic
from volatility3.plugins.windows import pslist, netscan, malfind, modules, handles
from typing import Dict, List
from datetime import datetime
from utils.logging_utils import setup_logging
from utils.file_utils import create_safe_directory
from .base import AnalyzerBase

class MemoryAnalyzer(AnalyzerBase):

    def __init__(self, memory_dump: str):
        super().__init__()
        self.memory_dump = memory_dump
        self.logger = setup_logging('data/logs')
        self.output_dir = 'data/memory_analysis'
        self.context = None

    def analyze(self) -> Dict:

        try:
            self._start_analysis()
            self.logger.info(f"Starting memory analysis of {self.memory_dump}")
            
            create_safe_directory(self.output_dir)
            self.context = self._init_volatility_context()
            
            results = {
                'processes': self._analyze_processes(),
                'network_connections': self._analyze_network(),
                'injected_code': self._find_code_injection(),
                'loaded_modules': self._analyze_modules(),
                'handles': self._analyze_handles(),
                'metadata': self._add_metadata(),
                'timestamp': datetime.now().isoformat()
            }
            
            self._end_analysis()
            self.logger.info("Memory analysis completed successfully")
            return results
            
        except Exception as e:
            self.logger.error(f"Memory analysis failed: {str(e)}")
            return {'error': str(e)}

    def _init_volatility_context(self):
        try:
            context = contexts.Context()
            context.config['automagic.LayerStacker.single_location'] = self.memory_dump
            automagic.available(context)
            return context
        except Exception as e:
            self.logger.error(f"Failed to initialize Volatility context: {str(e)}")
            raise

    def _analyze_processes(self) -> List[Dict]:
        try:
            processes = []
            plugin = pslist.PsList(self.context)
            tree = plugin.run()
            
            for proc in tree:
                processes.append({
                    'pid': proc.ProcessId,
                    'ppid': proc.ParentProcessId,
                    'name': proc.ImageFileName.cast("string"),
                    'start_time': proc.CreateTime.as_datetime().isoformat(),
                    'threads': proc.ActiveThreads,
                    'handles': proc.HandleCount
                })
            
            return processes
        except Exception as e:
            self.logger.error(f"Process analysis failed: {str(e)}")
            return []

    def _analyze_network(self) -> List[Dict]:
        try:
            connections = []
            plugin = netscan.NetScan(self.context)
            
            for conn in plugin.run():
                if hasattr(conn, 'LocalEndpoint') and hasattr(conn, 'RemoteEndpoint'):
                    connections.append({
                        'local': f"{conn.LocalEndpoint.Address}:{conn.LocalEndpoint.Port}",
                        'remote': f"{conn.RemoteEndpoint.Address}:{conn.RemoteEndpoint.Port}",
                        'state': conn.State,
                        'pid': conn.OwningProcessId
                    })
            return connections
        except Exception as e:
            self.logger.error(f"Network analysis failed: {str(e)}")
            return []

    def _find_code_injection(self) -> List[Dict]:
        try:
            injections = []
            plugin = malfind.Malfind(self.context)
            
            for injection in plugin.run():
                injections.append({
                    'pid': injection.UniqueProcessId,
                    'start_address': hex(injection.StartingVpn),
                    'end_address': hex(injection.EndingVpn),
                    'protection': injection.VadFlags.Protection.string,
                    'tag': injection.VadTag
                })
            return injections
        except Exception as e:
            self.logger.error(f"Code injection analysis failed: {str(e)}")
            return []

    def _analyze_modules(self) -> List[Dict]:
        try:
            loaded_modules = []
            plugin = modules.Modules(self.context)
            
            for module in plugin.run():
                loaded_modules.append({
                    'name': module.BaseDllName.get_string(),
                    'base': hex(module.DllBase),
                    'size': module.SizeOfImage,
                    'file_path': module.FullDllName.get_string()
                })
            
            return loaded_modules
        except Exception as e:
            self.logger.error(f"Module analysis failed: {str(e)}")
            return []

    def _analyze_handles(self) -> List[Dict]:
        try:
            handle_list = []
            plugin = handles.Handles(self.context)
            
            for handle in plugin.run():
                handle_list.append({
                    'pid': handle.ProcessId,
                    'handle_value': handle.HandleValue,
                    'type': handle.ObjectType.cast("string"),
                    'name': handle.NameInfo.cast("string") if handle.NameInfo else "",
                    'granted_access': hex(handle.GrantedAccess)
                })
            
            return handle_list
        except Exception as e:
            self.logger.error(f"Handle analysis failed: {str(e)}")
            return []