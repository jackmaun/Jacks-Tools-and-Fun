import os
import sys
import subprocess
import platform
import logging
from pathlib import Path

logger = logging.getLogger('sandbox_utils')

class NetworkIsolationError(Exception):
    pass

def is_in_vm() -> bool:
    vm_identifiers = ['VMware', 'VBox', 'QEMU', 'Virtual']
    
    try:
        if platform.system().lower() == 'windows':
            import wmi
            w = wmi.WMI()
            
            for system in w.Win32_ComputerSystem():
                if any(id.lower() in system.Manufacturer.lower() for id in vm_identifiers):
                    return True
                
            for bios in w.Win32_BIOS():
                if any(id.lower() in bios.Manufacturer.lower() for id in vm_identifiers):
                    return True
                    
        elif platform.system().lower() == 'linux':
            if os.path.exists('/sys/class/dmi/id/sys_vendor'):
                with open('/sys/class/dmi/id/sys_vendor', 'r') as f:
                    vendor = f.read().strip()
                    if any(id.lower() in vendor.lower() for id in vm_identifiers):
                        return True
                        
        elif platform.system().lower() == 'darwin':
            try:
                output = subprocess.check_output(['sysctl', 'machdep.cpu.features']).decode()
                if 'VMM' in output:
                    return True
            except:
                pass
    except Exception as e:
        logger.warning(f"VM detection error: {str(e)}")
        
    return False

def isolate_network() -> bool:
    try:
        system = platform.system().lower()
        
        if system == "windows":
            return _isolate_network_windows()
        elif system == "linux":
            return _isolate_network_linux()
        elif system == "darwin":
            return _isolate_network_macos()
        else:
            logger.error(f"Unsupported operating system: {system}")
            return False
            
    except Exception as e:
        logger.error(f"Network isolation failed: {str(e)}")
        return False

def _isolate_network_windows() -> bool:
    try:
        subprocess.run(["netsh", "interface", "set", "interface", "Ethernet", "admin=disabled"], check=True)
        
        rules = [
            ["netsh", "advfirewall", "set", "allprofiles", "state", "on"],
            ["netsh", "advfirewall", "set", "allprofiles", "firewallpolicy", "blockinbound,blockoutbound"],
            ["netsh", "advfirewall", "firewall", "add", "rule", "name=DNS-Out", "dir=out", "action=allow", "protocol=UDP", "localport=53"]
        ]
        
        for rule in rules:
            subprocess.run(rule, check=True)
            
        return True
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Windows network isolation failed: {str(e)}")
        return False

def _isolate_network_linux() -> bool:
    try:
        commands = [
            ["ip", "netns", "add", "malware_sandbox"],
            ["ip", "link", "set", "eth0", "netns", "malware_sandbox"],
            ["iptables", "-P", "INPUT", "DROP"],
            ["iptables", "-P", "OUTPUT", "DROP"],
            ["iptables", "-P", "FORWARD", "DROP"],
        ]
        
        for cmd in commands:
            subprocess.run(cmd, check=True)
            
        return True
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Linux network isolation failed: {str(e)}")
        return False

def _isolate_network_macos() -> bool:
    try:
        pf_rules = """
        set block-policy drop
        block all
        block return
        """
        
        rules_path = Path("/tmp/pf.rules")
        rules_path.write_text(pf_rules)
        
        commands = [
            ["pfctl", "-e"],
            ["pfctl", "-f", str(rules_path)]
        ]
        
        for cmd in commands:
            subprocess.run(cmd, check=True)
            
        return True
        
    except subprocess.CalledProcessError as e:
        logger.error(f"macOS network isolation failed: {str(e)}")
        return False

def restore_network() -> bool:
    try:
        system = platform.system().lower()
        
        if system == "windows":
            subprocess.run(["netsh", "interface", "set", "interface", "Ethernet", "admin=enabled"], check=True)
            subprocess.run(["netsh", "advfirewall", "reset"], check=True)
            
        elif system == "linux":
            subprocess.run(["ip", "netns", "del", "malware_sandbox"], check=True)
            subprocess.run(["iptables", "-F"], check=True)
            subprocess.run(["iptables", "-P", "INPUT", "ACCEPT"], check=True)
            subprocess.run(["iptables", "-P", "OUTPUT", "ACCEPT"], check=True)
            
        elif system == "darwin":
            subprocess.run(["pfctl", "-d"], check=True)
            
        return True
        
    except Exception as e:
        logger.error(f"Network restoration failed: {str(e)}")
        return False